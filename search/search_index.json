{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Taller de Introducci\u00f3n a Django \u00b6 El taller est\u00e1 pensado para iniciarse en Django en aproximadamente una hora . Requisitos \u00b6 Requiere tener Python 3 instalado , y un conocimiento b\u00e1sico tanto de Python como de tecnolog\u00edas web (HTTP y HTML). Instalaci\u00f3n \u00b6 Django \u00b6 Primero, instalaremos el paquete Django a trav\u00e9s de pip , el instalador de paquetes de Python (viene por defecto incluido en su instalaci\u00f3n): Linux/UNIX pip3 install Django Max OS X pip3 install Django Windows pip install Django Proyecto \u00b6 En Django, un proyecto o project es un conjunto de carpetas y archivos (un esqueleto ) donde desarrollaremos el sitio web. Vamos a crear un proyecto de Django e iniciar el servidor de desarrollo : Linux/UNIX django-admin startproject mysite cd mysite python3 manage.py runserver Mac OS X django-admin startproject mysite cd mysite python3 manage.py runserver Windows django-admin . exe startproject mysite cd mysite python manage . py runserver Con \u00e9sto habremos creado un un nuevo proyecto Django llamado mysite , y el servidor de desarrollo estar\u00e1 corriendo en el puerto por defecto (8000). En nuestro navegador abrimos 127.0.0.1:8000 y confirmamos que estamos viendo la p\u00e1gina inicial del proyecto, que tendr\u00e1 el siguiente mensaje: The install worked successfully! Congratulations! Abre la carpeta con tu editor de c\u00f3digo favorito. Ver\u00e1s los siguientes archivos: db.sqlite3 : Base de datos por defecto, en SQLite 3 . manage.py : Ejecutable para administrar el proyecto. Con \u00e9l hemos iniciado el servidor de desarrollo. mysite : M\u00f3dulo que engloba diferentes funcionalidades a nivel de proyecto. settings.py : Contiene la configuraci\u00f3n. Entre otras cosas, define la base de datos. urls.py : Contiene la lista de URLs mapeadas a la l\u00f3gica. wsgi.py : Define la Web Server Gateway Interface que usar\u00edamos en producci\u00f3n. Podemos ignorarlo para este taller. Vistas \u00b6 Las vistas o views en Django son funciones Python que procesan las peticiones HTTP. Ser\u00edan el controlador en el patr\u00f3n de arquitectura Modelo-Vista-Controlador (en Django la nomenclatura es diferente ). Para crear una vista, primero necesitamos una aplicaci\u00f3n en la que definirla. Aplicaci\u00f3n \u00b6 Las aplicaciones son un m\u00f3dulo de Python que reunir\u00e1 un conjunto de funcionalidades (l\u00f3gica, modelos, etc). Adem\u00e1s, podremos reutilizarlas en otros proyectos . Vamos a crear una aplicaci\u00f3n de ejemplo para gestionar notas. Usando manage.py startapp , crearemos una aplicaci\u00f3n llamada notes : Linux/UNIX python3 manage.py startapp notes Mac OS X python3 manage.py startapp notes Windows python manage . py startapp notes El comando crear\u00e1 un modulo con los siguientes archivos: admin.py : Integraci\u00f3n con el panel administrativo de Django. apps.py : Propiedades de la aplicaci\u00f3n (por ejemplo el nombre). migrations/ : Carpeta que contendr\u00e1 las futuras migraciones de la base de datos. models.py : Definici\u00f3n de los modelos del ORM de Django. tests.py : Definici\u00f3n de los tests. views.py : Definici\u00f3n de las vistas . Para acabar, vamos a instalar la aplicaci\u00f3n en el proyecto. \u00c9sto nos permitir\u00e1 integrarla m\u00e1s adelante con muchas de las funcionalidades de Django, como el ORM o el motor de plantillas ( templates ). Abre mysite/settings.py con tu editor de c\u00f3digo favorito y a\u00f1ade notes (el nombre de la aplicaci\u00f3n) a la lista de INSTALLED_APPS . INSTALLED_APPS = [ 'django.contrib.admin' , 'django.contrib.auth' , 'django.contrib.contenttypes' , 'django.contrib.sessions' , 'django.contrib.messages' , 'django.contrib.staticfiles' , 'notes' , ] Vista \u00b6 En Django, una vista es una funci\u00f3n que recibe un objeto HttpRequest y devuelve un objeto HttpResponse . Por ejemplo: def hello_world ( request : HttpRequest ): return HttpResponse ( 'Hello World!' ) \u00c9sta vista devolver\u00eda una respuesta en texto plano . Pero nosotros vamos a definir una vista que devuelva texto HTML . Abre notes/views.py y define la siguiente vista: from django.shortcuts import render def index ( request ): template = 'index.html' context = { 'note_list' : [ { 'title' : 'Sin noticias de Gurb' , 'content' : 'Libro de Eduardo Mendoza' }, { 'title' : '\u00bfQu\u00e9 hace un perro con un taladro?' , 'content' : 'Taladrando' }, ] } response = render ( request , template , context ) return response El m\u00e9todo render pinta una plantilla ( template ) HTML usando el motor de plantillas de Django y devuelve el resultado como un objeto HttpResponse . Recuerda que en Django las vistas deben devolver una instancia de esta clase. Veamos que par\u00e1metros pasamos a render : - En template pasamos notes/index.html , que es el fichero con la plantilla HTML a pintar. Lo crearemos en la secci\u00f3n siguiente. - En context pasamos un mapa ( dict ) con una serie de valores a ser usados por la plantilla. En este caso hemos definido una lista arbitraria de notas, y cada una de ellas es a su vez otro mapa con un t\u00edtulo y un contenido. Plantilla HTML \u00b6 Ahora, vamos a crear la plantilla HTML . Por defecto, Django busca plantillas en la carpeta templates de cada aplicaci\u00f3n instalada . As\u00ed que vamos a crear una carpeta llamada templates dentro de mysite/notes/ : Linux/UNIX mkdir notes/templates Max OS X mkdir notes/templates Windows mkdir notes / templates Y ahora en esa carpeta crea un nuevo archivo index.html (la ruta completa ser\u00eda notes/templates/index.html ) con el siguiente contenido: <!DOCTYPE html> < html > < head > < title > Notas </ title > </ head > < body > < h1 > Notas </ h1 > {% for note in note_list %} < h2 > {{ note.title }} </ h2 > < p > {{ note.content }} </ p > {% endfor %} </ body > </ html > La plantilla imprimir\u00e1 un documento HTML con los t\u00edtulos y el contenido de las notas que hemos pasado en el contexto , gracias al bucle for . En el lenguaje de plantillas de Django, podemos imprimir las variables recibidas del contexto envolvi\u00e9ndolas entre {{ y }} . Adem\u00e1s, podemos usar controles de flujo b\u00e1sicos (como for , if , etc) usando lo que en Django se denominan tags . La sintaxis puede variar, pero siempre estar\u00e1 envuelta entre {% y %} . URL \u00b6 Por \u00faltimo, debemos mapear una URL a la vista que hemos definido. Para ello, a\u00f1adiremos una ruta ( path ) a la lista urlpatterns de mysite/urls.py : from django.contrib import admin from django.urls import path from notes import views urlpatterns = [ path ( '' , views . index ), path ( 'admin/' , admin . site . urls ), ] Hemos mapeado la vista a la ruta ra\u00edz '' , de forma que si ahora refrescamos la p\u00e1gina 127.0.0.1:8000 , veremos el resultado. Si lo hubi\u00e9semos mapeado tal que path('notes', views.index) , la URL ser\u00eda 127.0.0.1:8000/notas . F\u00edjate que el servidor de desarrollo ha detectado las modificaciones y se ha reiniciado autom\u00e1ticamente, aplicando los cambios sin necesidad de apagarlo y volverlo a encender manualmente. Modelos \u00b6 En Django, los modelos son la \u00fanica fuente de informaci\u00f3n de tus datos. Con ellos: - Definimos su esquema . - Gestionamos los cambios del esquema ( migraciones ). - Consultamos y manipulamos los registros. Los modelos implementan el patr\u00f3n ORM . Django trabaja con bases de datos relacionales . Recuerda que por defecto utiliza SQLite 3 . Simplificando, podemos pensar que las bases de datos relacionales almacenan la informaci\u00f3n en tablas ( esquemas ), donde las columnas son las propiedades y las filas cada uno de los registros. En nuestro proyecto en concreto, podr\u00edamos almacenar las notas en una tabla con las columnas \"t\u00edtulo\" y \"contenido\" ( title y content ), donde las filas ser\u00edan cada una de nuestras notas. Vamos a definir un modelo para ello. Abre el archivo notes/models.py y a\u00f1ade las siguientes l\u00edneas: from django.db import models class Note ( models . Model ): title = models . CharField ( max_length = 50 ) content = models . TextField () def __str__ ( self ): return self . title En Django, los modelos deben extender models.Model . Las clases CharField y TextField son algunos de los campos que podemos definir en nuestro modelo, pero hay muchos m\u00e1s . F\u00edjate que hemos sobreescrito el m\u00e9todo m\u00e1gico de Python __str__ . Django utilizar\u00e1 \u00e9ste m\u00e9todo en diversos sitios , y adem\u00e1s facilitar\u00e1 la depuraci\u00f3n de la aplicaci\u00f3n. Si no lo sobreescribimos, el modelo por defecto devolver\u00e1 el id del registro. Migraciones \u00b6 Tenemos el modelo pero, antes de ponernos a crear registros, tenemos que crear la tabla donde se van a guardar. Para los cambios de esquema usaremos migraciones . Django tiene un comando para crear migraciones, detectando autom\u00e1ticamente los cambios realizados en los modelos. Ejecuta el siguiente comando, que buscar\u00e1 estos cambios en la aplicaci\u00f3n notes : Linux/UNIX python3 manage.py makemigrations notes Mac OS X python3 manage.py makemigrations notes Windows python manage . py makemigrations notes Esto habr\u00e1 creado un archivo de migraci\u00f3n en notes/migrations/0001_initial.py . Si lo abres, podr\u00e1s ver instrucciones para crear la tabla en la base de datos con los campos que hemos definido en el modelo. F\u00edjate que autom\u00e1ticamente ha a\u00f1adido una clave primaria, llamada por defecto id , sin necesidad de declararla en el modelo. Todos los modelos de Django tienen impl\u00edcitamente un campo id . Para crear la tabla en la base de datos, ejecutamos el comando migrate : Linux/UNIX python3 manage.py migrate notes Mac OS X python3 manage.py migrate notes Windows python manage . py migrate notes Este comando aplicar\u00e1 las migraciones pendientes de la aplicaci\u00f3n notes . Django lleva un registro de las migraciones aplicadas en otra tabla creada por defecto. Podemos abrir una consola en la base de datos del proyecto con el comando dbshell , y listar las tablas creadas con .tables : Linux/UNIX $ python3 manage.py dbshell SQLite version 3 .24.0 2018 -06-04 14 :10:15 Enter \".help\" for usage hints. sqlite> .tables django_migrations notes_note Mac OS X $ python3 manage.py dbshell SQLite version 3 .24.0 2018 -06-04 14 :10:15 Enter \".help\" for usage hints. sqlite> .tables django_migrations notes_note Windows $ python manage . py dbshell SQLite version 3 . 24 . 0 2018 - 06 - 04 14 : 10 : 15 Enter \".help\" for usage hints . sqlite > . tables django_migrations notes_note Las tablas creadas por defecto en Django est\u00e1n formadas por el nombre de la aplicaci\u00f3n, un gui\u00f3n bajo ( _ ), y el nombre del modelo (en min\u00fascula y sin espacios). Por eso la tabla se ha creado con el nombre notes_note (recuerda que la aplicaci\u00f3n se llama notes , y el modelo note ). Crear, actualizar y borrar \u00b6 Para crear algunos registros de ejemplo vamos a abrir una consola interactiva ( REPL ) de Django con el comando shell : Linux/UNIX python3 manage.py shell Mac OS X python3 manage.py shell Windows python manage . py shell Una vez dentro de la consola, importamos el modelo: from notes.models import Note Podemos crear registros instanciando la clase del modelo (en este caso Note ) pasando sus valores al constructor, y posteriormente llamando al m\u00e9todo save : note = Note ( title = 'El Guateque' , content = 'Pel\u00edcula sobre una animada fiesta' ) note . save () El registro no se insertar\u00e1 en la base de datos hasta que llamemos a save , que al ser un registro nuevo ejecutar\u00e1 un INSERT . Podemos actualizar el registro cambiando el valor de sus atributos en la instancia y llamando de nuevo a save , el cual \u00e9sta vez realizar\u00e1 un UPDATE : note . title = \"Pulp Fiction\" note . save () Por \u00faltimo, podemos borrar el registro llamando a delete , el cual ejecutar\u00e1 un DELETE . note . delete () No cierres la consola de Django, la necesitaremos para la secci\u00f3n siguiente. Manager \u00b6 En Django, los modelos tienen por defecto un manager para interactuar con la base de datos. Todos los modelos tienen un manager en el atributo de clase objects . En los ejemplos anteriores, cuando llamamos a save , por debajo se est\u00e1 llamando al manager del modelo. Vamos a crear un par de registros de ejemplo usando directamente el manager desde la consola de Django: Note . objects . create ( title = 'El Guateque' , content = 'Pel\u00edcula sobre una animada fiesta' ) Note . objects . create ( title = 'Hyperion' , content = 'Libro de Dan Simmons' ) Pero lo m\u00e1s importante es que objects nos va a permitir hacer consultas a la base de datos para leer los registros guardados. Ejecuta la siguiente l\u00ednea para ver una lista con los registros que acabamos de crear: Note . objects . all () objects ofrece muchos m\u00e9todos para realizar consultas , pero de momento nos quedamos con all , la cual devuelve todos los registros. Cierra la shell de Django escribiendo exit() : exit () Vamos a cambiar la vista index para que lea los registros de la base de datos. Abre notes/views.py y reemplaza el valor de note_list del contexto de la vista: from django.shortcuts import render from notes.models import Notes def index ( request ): template = 'index.html' context = { 'note_list' : Notes . objects . all () } response = render ( request , template , context ) return response Si ahora refrescamos la p\u00e1gina 127.0.0.1:8000 , veremos que muestra los registros que hemos creado (\"El Guateque\" e \"Hyperion\"). Administraci\u00f3n \u00b6 Django ofrece por defecto un panel de administraci\u00f3n web que nos permitir\u00e1 gestionar los registros de la base de datos f\u00e1cilmente. \u00c9ste, a su vez, depende de otras aplicaciones que instala Django por defecto para gestionar usuarios y sesiones. Para empezar a usar la administraci\u00f3n, primero debemos aplicar las migraciones de estos modelos. Ejecutemos el comando migrate : Linux/UNIX python3 manage.py migrate Max OS X python3 manage.py migrate Windows python manage . py migrate Veremos que ejecuta migraciones de diferentes aplicaciones. Ahora vamos a crear un usuario administrador para poder iniciar sesi\u00f3n en la administraci\u00f3n. Ejecuta el comando createsuperuser y responde sus preguntas: Linux/UNIX python3 manage.py createsuperuser Max OS X python3 manage.py createsuperuser Windows python manage . py createsuperuser Ahora abrimos la p\u00e1gina de administraci\u00f3n en 127.0.0.1:8000/admin e iniciamos sesi\u00f3n con el nombre de usuario y password que acabamos de crear. Ver\u00e1s que, entre otras cosas, puedes gestionar los usuarios desde ah\u00ed. Integraci\u00f3n con el modelo \u00b6 Vamos a registrar el modelo Note en la administraci\u00f3n para que podamos gestionar los registros desde all\u00ed. Para ello, abrimos notes/admin.py , importamos el modelo Note , y lo regisramos con admin.site.register : from django.contrib import admin from .models import Note admin . site . register ( Note ) Si refrescamos el panel de administraci\u00f3n en 127.0.0.1:8000/admin , veremos que ahora podemos gestionar los registros del modelo desde all\u00ed. Prueba a a\u00f1adir algunas notas de ejemplo usando la administraci\u00f3n, vuelve a la p\u00e1gina ra\u00edz del proyecto , y comprueba que se muestran correctamente. Tests \u00b6 Para acabar, vamos a escribir algunos tests para comprobar de forma autom\u00e1tica el funcionamiento de la aplicaci\u00f3n. Django ofrece una clase TestCase , que extiende unittest.TestCase con algunas funcionalidades espec\u00edficas para escribir tests en Django. Una de las m\u00e1s importantes es que incluye un cliente ( self.client ) y un servidor para realizar peticiones a las vistas de la aplicaci\u00f3n. Adem\u00e1s, cada test estar\u00e1 envuelto en una transacci\u00f3n, de forma que podemos usar diferentes conjuntos de datos f\u00e1cilmente. Tests para la vista \u00b6 Abrimos notes/tests.py y a\u00f1adimos los siguiente test: from django.test import TestCase from .models import Note class IndexViewTests ( TestCase ): def test_index_shows_all_notes ( self ): Note . objects . create ( title = \"Test\" , content = \"I am a test note\" ) response = self . client . get ( '/' ) self . assertEqual ( response . status_code , 200 ) self . assertContains ( response , '<p>I am a test note</p>' ) self . assertQuerysetEqual ( response . context [ 'note_list' ], [ '<Note: Test>' ]) def test_index_shows_empty ( self ): response = self . client . get ( '/' ) self . assertEqual ( response . status_code , 200 ) self . assertNotContains ( response , '<p>I am a test note</p>' ) self . assertQuerysetEqual ( response . context [ 'note_list' ], []) El primer test crea una de ejemplo en la base de datos y llama a la URL ra\u00edz ( / ). Despu\u00e9s comprueba que la p\u00e1gina HTML recibida est\u00e1 imprimiendo el contenido de la nota correctamente y que el contexto de la vista es el esperado ( <Note: Test> es el resultado de evaluarse el modelo como una string a trav\u00e9s del m\u00e9todo __str__ que sobreescribimos en el modelo). El segundo test comprueba que cuando la base de datos est\u00e1 vac\u00eda no se imprime ninguna nota. F\u00edjate que el registro creado en el primer test no estar\u00e1 disponible en el segundo ( assertNotContains ) debido a que cada test est\u00e1 envuelto en una transacci\u00f3n que que no se llega a completar. Ejecuci\u00f3n \u00b6 Para ejecutar los tests, usaremos el comando test : Linux/UNIX python3 manage.py test Max OS X python3 manage.py test Windows python manage . py test Veremos una salida similar a \u00e9sta: Creating test database for alias ' default ' ... System check identified no issues ( 0 silenced ) . .. ---------------------------------------------------------------------- Ran 2 tests in 0 . 009 s OK Destroying test database for alias ' default ' ... F\u00edjate que ha creado una base de datos de prueba al principio de la ejecuci\u00f3n, y la ha destruido al terminar. \u00c9sta base de datos es creada exclusivamente para correr los tests. Siguientes pasos \u00b6 A continuaci\u00f3n se dan algunas sugerencias para continuar aprendiendo con \u00e9ste proyecto: A\u00f1adir una plantilla base . A\u00f1adir una clave for\u00e1nea en el modelo Note al modelo User . Implementar la vista index como una vista basada en clases ( class based views ) . Para leer m\u00e1s \u00b6 Algunos tutoriales m\u00e1s detallados: Django Tutorial . Django Girls Tutorial . Gu\u00edas de Django, por Mozilla .","title":"Taller de Introducci\u00f3n a Django"},{"location":"#taller-de-introduccion-a-django","text":"El taller est\u00e1 pensado para iniciarse en Django en aproximadamente una hora .","title":"Taller de Introducci\u00f3n a Django"},{"location":"#requisitos","text":"Requiere tener Python 3 instalado , y un conocimiento b\u00e1sico tanto de Python como de tecnolog\u00edas web (HTTP y HTML).","title":"Requisitos"},{"location":"#instalacion","text":"","title":"Instalaci\u00f3n"},{"location":"#django","text":"Primero, instalaremos el paquete Django a trav\u00e9s de pip , el instalador de paquetes de Python (viene por defecto incluido en su instalaci\u00f3n): Linux/UNIX pip3 install Django Max OS X pip3 install Django Windows pip install Django","title":"Django"},{"location":"#proyecto","text":"En Django, un proyecto o project es un conjunto de carpetas y archivos (un esqueleto ) donde desarrollaremos el sitio web. Vamos a crear un proyecto de Django e iniciar el servidor de desarrollo : Linux/UNIX django-admin startproject mysite cd mysite python3 manage.py runserver Mac OS X django-admin startproject mysite cd mysite python3 manage.py runserver Windows django-admin . exe startproject mysite cd mysite python manage . py runserver Con \u00e9sto habremos creado un un nuevo proyecto Django llamado mysite , y el servidor de desarrollo estar\u00e1 corriendo en el puerto por defecto (8000). En nuestro navegador abrimos 127.0.0.1:8000 y confirmamos que estamos viendo la p\u00e1gina inicial del proyecto, que tendr\u00e1 el siguiente mensaje: The install worked successfully! Congratulations! Abre la carpeta con tu editor de c\u00f3digo favorito. Ver\u00e1s los siguientes archivos: db.sqlite3 : Base de datos por defecto, en SQLite 3 . manage.py : Ejecutable para administrar el proyecto. Con \u00e9l hemos iniciado el servidor de desarrollo. mysite : M\u00f3dulo que engloba diferentes funcionalidades a nivel de proyecto. settings.py : Contiene la configuraci\u00f3n. Entre otras cosas, define la base de datos. urls.py : Contiene la lista de URLs mapeadas a la l\u00f3gica. wsgi.py : Define la Web Server Gateway Interface que usar\u00edamos en producci\u00f3n. Podemos ignorarlo para este taller.","title":"Proyecto"},{"location":"#vistas","text":"Las vistas o views en Django son funciones Python que procesan las peticiones HTTP. Ser\u00edan el controlador en el patr\u00f3n de arquitectura Modelo-Vista-Controlador (en Django la nomenclatura es diferente ). Para crear una vista, primero necesitamos una aplicaci\u00f3n en la que definirla.","title":"Vistas"},{"location":"#aplicacion","text":"Las aplicaciones son un m\u00f3dulo de Python que reunir\u00e1 un conjunto de funcionalidades (l\u00f3gica, modelos, etc). Adem\u00e1s, podremos reutilizarlas en otros proyectos . Vamos a crear una aplicaci\u00f3n de ejemplo para gestionar notas. Usando manage.py startapp , crearemos una aplicaci\u00f3n llamada notes : Linux/UNIX python3 manage.py startapp notes Mac OS X python3 manage.py startapp notes Windows python manage . py startapp notes El comando crear\u00e1 un modulo con los siguientes archivos: admin.py : Integraci\u00f3n con el panel administrativo de Django. apps.py : Propiedades de la aplicaci\u00f3n (por ejemplo el nombre). migrations/ : Carpeta que contendr\u00e1 las futuras migraciones de la base de datos. models.py : Definici\u00f3n de los modelos del ORM de Django. tests.py : Definici\u00f3n de los tests. views.py : Definici\u00f3n de las vistas . Para acabar, vamos a instalar la aplicaci\u00f3n en el proyecto. \u00c9sto nos permitir\u00e1 integrarla m\u00e1s adelante con muchas de las funcionalidades de Django, como el ORM o el motor de plantillas ( templates ). Abre mysite/settings.py con tu editor de c\u00f3digo favorito y a\u00f1ade notes (el nombre de la aplicaci\u00f3n) a la lista de INSTALLED_APPS . INSTALLED_APPS = [ 'django.contrib.admin' , 'django.contrib.auth' , 'django.contrib.contenttypes' , 'django.contrib.sessions' , 'django.contrib.messages' , 'django.contrib.staticfiles' , 'notes' , ]","title":"Aplicaci\u00f3n"},{"location":"#vista","text":"En Django, una vista es una funci\u00f3n que recibe un objeto HttpRequest y devuelve un objeto HttpResponse . Por ejemplo: def hello_world ( request : HttpRequest ): return HttpResponse ( 'Hello World!' ) \u00c9sta vista devolver\u00eda una respuesta en texto plano . Pero nosotros vamos a definir una vista que devuelva texto HTML . Abre notes/views.py y define la siguiente vista: from django.shortcuts import render def index ( request ): template = 'index.html' context = { 'note_list' : [ { 'title' : 'Sin noticias de Gurb' , 'content' : 'Libro de Eduardo Mendoza' }, { 'title' : '\u00bfQu\u00e9 hace un perro con un taladro?' , 'content' : 'Taladrando' }, ] } response = render ( request , template , context ) return response El m\u00e9todo render pinta una plantilla ( template ) HTML usando el motor de plantillas de Django y devuelve el resultado como un objeto HttpResponse . Recuerda que en Django las vistas deben devolver una instancia de esta clase. Veamos que par\u00e1metros pasamos a render : - En template pasamos notes/index.html , que es el fichero con la plantilla HTML a pintar. Lo crearemos en la secci\u00f3n siguiente. - En context pasamos un mapa ( dict ) con una serie de valores a ser usados por la plantilla. En este caso hemos definido una lista arbitraria de notas, y cada una de ellas es a su vez otro mapa con un t\u00edtulo y un contenido.","title":"Vista"},{"location":"#plantilla-html","text":"Ahora, vamos a crear la plantilla HTML . Por defecto, Django busca plantillas en la carpeta templates de cada aplicaci\u00f3n instalada . As\u00ed que vamos a crear una carpeta llamada templates dentro de mysite/notes/ : Linux/UNIX mkdir notes/templates Max OS X mkdir notes/templates Windows mkdir notes / templates Y ahora en esa carpeta crea un nuevo archivo index.html (la ruta completa ser\u00eda notes/templates/index.html ) con el siguiente contenido: <!DOCTYPE html> < html > < head > < title > Notas </ title > </ head > < body > < h1 > Notas </ h1 > {% for note in note_list %} < h2 > {{ note.title }} </ h2 > < p > {{ note.content }} </ p > {% endfor %} </ body > </ html > La plantilla imprimir\u00e1 un documento HTML con los t\u00edtulos y el contenido de las notas que hemos pasado en el contexto , gracias al bucle for . En el lenguaje de plantillas de Django, podemos imprimir las variables recibidas del contexto envolvi\u00e9ndolas entre {{ y }} . Adem\u00e1s, podemos usar controles de flujo b\u00e1sicos (como for , if , etc) usando lo que en Django se denominan tags . La sintaxis puede variar, pero siempre estar\u00e1 envuelta entre {% y %} .","title":"Plantilla HTML"},{"location":"#url","text":"Por \u00faltimo, debemos mapear una URL a la vista que hemos definido. Para ello, a\u00f1adiremos una ruta ( path ) a la lista urlpatterns de mysite/urls.py : from django.contrib import admin from django.urls import path from notes import views urlpatterns = [ path ( '' , views . index ), path ( 'admin/' , admin . site . urls ), ] Hemos mapeado la vista a la ruta ra\u00edz '' , de forma que si ahora refrescamos la p\u00e1gina 127.0.0.1:8000 , veremos el resultado. Si lo hubi\u00e9semos mapeado tal que path('notes', views.index) , la URL ser\u00eda 127.0.0.1:8000/notas . F\u00edjate que el servidor de desarrollo ha detectado las modificaciones y se ha reiniciado autom\u00e1ticamente, aplicando los cambios sin necesidad de apagarlo y volverlo a encender manualmente.","title":"URL"},{"location":"#modelos","text":"En Django, los modelos son la \u00fanica fuente de informaci\u00f3n de tus datos. Con ellos: - Definimos su esquema . - Gestionamos los cambios del esquema ( migraciones ). - Consultamos y manipulamos los registros. Los modelos implementan el patr\u00f3n ORM . Django trabaja con bases de datos relacionales . Recuerda que por defecto utiliza SQLite 3 . Simplificando, podemos pensar que las bases de datos relacionales almacenan la informaci\u00f3n en tablas ( esquemas ), donde las columnas son las propiedades y las filas cada uno de los registros. En nuestro proyecto en concreto, podr\u00edamos almacenar las notas en una tabla con las columnas \"t\u00edtulo\" y \"contenido\" ( title y content ), donde las filas ser\u00edan cada una de nuestras notas. Vamos a definir un modelo para ello. Abre el archivo notes/models.py y a\u00f1ade las siguientes l\u00edneas: from django.db import models class Note ( models . Model ): title = models . CharField ( max_length = 50 ) content = models . TextField () def __str__ ( self ): return self . title En Django, los modelos deben extender models.Model . Las clases CharField y TextField son algunos de los campos que podemos definir en nuestro modelo, pero hay muchos m\u00e1s . F\u00edjate que hemos sobreescrito el m\u00e9todo m\u00e1gico de Python __str__ . Django utilizar\u00e1 \u00e9ste m\u00e9todo en diversos sitios , y adem\u00e1s facilitar\u00e1 la depuraci\u00f3n de la aplicaci\u00f3n. Si no lo sobreescribimos, el modelo por defecto devolver\u00e1 el id del registro.","title":"Modelos"},{"location":"#migraciones","text":"Tenemos el modelo pero, antes de ponernos a crear registros, tenemos que crear la tabla donde se van a guardar. Para los cambios de esquema usaremos migraciones . Django tiene un comando para crear migraciones, detectando autom\u00e1ticamente los cambios realizados en los modelos. Ejecuta el siguiente comando, que buscar\u00e1 estos cambios en la aplicaci\u00f3n notes : Linux/UNIX python3 manage.py makemigrations notes Mac OS X python3 manage.py makemigrations notes Windows python manage . py makemigrations notes Esto habr\u00e1 creado un archivo de migraci\u00f3n en notes/migrations/0001_initial.py . Si lo abres, podr\u00e1s ver instrucciones para crear la tabla en la base de datos con los campos que hemos definido en el modelo. F\u00edjate que autom\u00e1ticamente ha a\u00f1adido una clave primaria, llamada por defecto id , sin necesidad de declararla en el modelo. Todos los modelos de Django tienen impl\u00edcitamente un campo id . Para crear la tabla en la base de datos, ejecutamos el comando migrate : Linux/UNIX python3 manage.py migrate notes Mac OS X python3 manage.py migrate notes Windows python manage . py migrate notes Este comando aplicar\u00e1 las migraciones pendientes de la aplicaci\u00f3n notes . Django lleva un registro de las migraciones aplicadas en otra tabla creada por defecto. Podemos abrir una consola en la base de datos del proyecto con el comando dbshell , y listar las tablas creadas con .tables : Linux/UNIX $ python3 manage.py dbshell SQLite version 3 .24.0 2018 -06-04 14 :10:15 Enter \".help\" for usage hints. sqlite> .tables django_migrations notes_note Mac OS X $ python3 manage.py dbshell SQLite version 3 .24.0 2018 -06-04 14 :10:15 Enter \".help\" for usage hints. sqlite> .tables django_migrations notes_note Windows $ python manage . py dbshell SQLite version 3 . 24 . 0 2018 - 06 - 04 14 : 10 : 15 Enter \".help\" for usage hints . sqlite > . tables django_migrations notes_note Las tablas creadas por defecto en Django est\u00e1n formadas por el nombre de la aplicaci\u00f3n, un gui\u00f3n bajo ( _ ), y el nombre del modelo (en min\u00fascula y sin espacios). Por eso la tabla se ha creado con el nombre notes_note (recuerda que la aplicaci\u00f3n se llama notes , y el modelo note ).","title":"Migraciones"},{"location":"#crear-actualizar-y-borrar","text":"Para crear algunos registros de ejemplo vamos a abrir una consola interactiva ( REPL ) de Django con el comando shell : Linux/UNIX python3 manage.py shell Mac OS X python3 manage.py shell Windows python manage . py shell Una vez dentro de la consola, importamos el modelo: from notes.models import Note Podemos crear registros instanciando la clase del modelo (en este caso Note ) pasando sus valores al constructor, y posteriormente llamando al m\u00e9todo save : note = Note ( title = 'El Guateque' , content = 'Pel\u00edcula sobre una animada fiesta' ) note . save () El registro no se insertar\u00e1 en la base de datos hasta que llamemos a save , que al ser un registro nuevo ejecutar\u00e1 un INSERT . Podemos actualizar el registro cambiando el valor de sus atributos en la instancia y llamando de nuevo a save , el cual \u00e9sta vez realizar\u00e1 un UPDATE : note . title = \"Pulp Fiction\" note . save () Por \u00faltimo, podemos borrar el registro llamando a delete , el cual ejecutar\u00e1 un DELETE . note . delete () No cierres la consola de Django, la necesitaremos para la secci\u00f3n siguiente.","title":"Crear, actualizar y borrar"},{"location":"#manager","text":"En Django, los modelos tienen por defecto un manager para interactuar con la base de datos. Todos los modelos tienen un manager en el atributo de clase objects . En los ejemplos anteriores, cuando llamamos a save , por debajo se est\u00e1 llamando al manager del modelo. Vamos a crear un par de registros de ejemplo usando directamente el manager desde la consola de Django: Note . objects . create ( title = 'El Guateque' , content = 'Pel\u00edcula sobre una animada fiesta' ) Note . objects . create ( title = 'Hyperion' , content = 'Libro de Dan Simmons' ) Pero lo m\u00e1s importante es que objects nos va a permitir hacer consultas a la base de datos para leer los registros guardados. Ejecuta la siguiente l\u00ednea para ver una lista con los registros que acabamos de crear: Note . objects . all () objects ofrece muchos m\u00e9todos para realizar consultas , pero de momento nos quedamos con all , la cual devuelve todos los registros. Cierra la shell de Django escribiendo exit() : exit () Vamos a cambiar la vista index para que lea los registros de la base de datos. Abre notes/views.py y reemplaza el valor de note_list del contexto de la vista: from django.shortcuts import render from notes.models import Notes def index ( request ): template = 'index.html' context = { 'note_list' : Notes . objects . all () } response = render ( request , template , context ) return response Si ahora refrescamos la p\u00e1gina 127.0.0.1:8000 , veremos que muestra los registros que hemos creado (\"El Guateque\" e \"Hyperion\").","title":"Manager"},{"location":"#administracion","text":"Django ofrece por defecto un panel de administraci\u00f3n web que nos permitir\u00e1 gestionar los registros de la base de datos f\u00e1cilmente. \u00c9ste, a su vez, depende de otras aplicaciones que instala Django por defecto para gestionar usuarios y sesiones. Para empezar a usar la administraci\u00f3n, primero debemos aplicar las migraciones de estos modelos. Ejecutemos el comando migrate : Linux/UNIX python3 manage.py migrate Max OS X python3 manage.py migrate Windows python manage . py migrate Veremos que ejecuta migraciones de diferentes aplicaciones. Ahora vamos a crear un usuario administrador para poder iniciar sesi\u00f3n en la administraci\u00f3n. Ejecuta el comando createsuperuser y responde sus preguntas: Linux/UNIX python3 manage.py createsuperuser Max OS X python3 manage.py createsuperuser Windows python manage . py createsuperuser Ahora abrimos la p\u00e1gina de administraci\u00f3n en 127.0.0.1:8000/admin e iniciamos sesi\u00f3n con el nombre de usuario y password que acabamos de crear. Ver\u00e1s que, entre otras cosas, puedes gestionar los usuarios desde ah\u00ed.","title":"Administraci\u00f3n"},{"location":"#integracion-con-el-modelo","text":"Vamos a registrar el modelo Note en la administraci\u00f3n para que podamos gestionar los registros desde all\u00ed. Para ello, abrimos notes/admin.py , importamos el modelo Note , y lo regisramos con admin.site.register : from django.contrib import admin from .models import Note admin . site . register ( Note ) Si refrescamos el panel de administraci\u00f3n en 127.0.0.1:8000/admin , veremos que ahora podemos gestionar los registros del modelo desde all\u00ed. Prueba a a\u00f1adir algunas notas de ejemplo usando la administraci\u00f3n, vuelve a la p\u00e1gina ra\u00edz del proyecto , y comprueba que se muestran correctamente.","title":"Integraci\u00f3n con el modelo"},{"location":"#tests","text":"Para acabar, vamos a escribir algunos tests para comprobar de forma autom\u00e1tica el funcionamiento de la aplicaci\u00f3n. Django ofrece una clase TestCase , que extiende unittest.TestCase con algunas funcionalidades espec\u00edficas para escribir tests en Django. Una de las m\u00e1s importantes es que incluye un cliente ( self.client ) y un servidor para realizar peticiones a las vistas de la aplicaci\u00f3n. Adem\u00e1s, cada test estar\u00e1 envuelto en una transacci\u00f3n, de forma que podemos usar diferentes conjuntos de datos f\u00e1cilmente.","title":"Tests"},{"location":"#tests-para-la-vista","text":"Abrimos notes/tests.py y a\u00f1adimos los siguiente test: from django.test import TestCase from .models import Note class IndexViewTests ( TestCase ): def test_index_shows_all_notes ( self ): Note . objects . create ( title = \"Test\" , content = \"I am a test note\" ) response = self . client . get ( '/' ) self . assertEqual ( response . status_code , 200 ) self . assertContains ( response , '<p>I am a test note</p>' ) self . assertQuerysetEqual ( response . context [ 'note_list' ], [ '<Note: Test>' ]) def test_index_shows_empty ( self ): response = self . client . get ( '/' ) self . assertEqual ( response . status_code , 200 ) self . assertNotContains ( response , '<p>I am a test note</p>' ) self . assertQuerysetEqual ( response . context [ 'note_list' ], []) El primer test crea una de ejemplo en la base de datos y llama a la URL ra\u00edz ( / ). Despu\u00e9s comprueba que la p\u00e1gina HTML recibida est\u00e1 imprimiendo el contenido de la nota correctamente y que el contexto de la vista es el esperado ( <Note: Test> es el resultado de evaluarse el modelo como una string a trav\u00e9s del m\u00e9todo __str__ que sobreescribimos en el modelo). El segundo test comprueba que cuando la base de datos est\u00e1 vac\u00eda no se imprime ninguna nota. F\u00edjate que el registro creado en el primer test no estar\u00e1 disponible en el segundo ( assertNotContains ) debido a que cada test est\u00e1 envuelto en una transacci\u00f3n que que no se llega a completar.","title":"Tests para la vista"},{"location":"#ejecucion","text":"Para ejecutar los tests, usaremos el comando test : Linux/UNIX python3 manage.py test Max OS X python3 manage.py test Windows python manage . py test Veremos una salida similar a \u00e9sta: Creating test database for alias ' default ' ... System check identified no issues ( 0 silenced ) . .. ---------------------------------------------------------------------- Ran 2 tests in 0 . 009 s OK Destroying test database for alias ' default ' ... F\u00edjate que ha creado una base de datos de prueba al principio de la ejecuci\u00f3n, y la ha destruido al terminar. \u00c9sta base de datos es creada exclusivamente para correr los tests.","title":"Ejecuci\u00f3n"},{"location":"#siguientes-pasos","text":"A continuaci\u00f3n se dan algunas sugerencias para continuar aprendiendo con \u00e9ste proyecto: A\u00f1adir una plantilla base . A\u00f1adir una clave for\u00e1nea en el modelo Note al modelo User . Implementar la vista index como una vista basada en clases ( class based views ) .","title":"Siguientes pasos"},{"location":"#para-leer-mas","text":"Algunos tutoriales m\u00e1s detallados: Django Tutorial . Django Girls Tutorial . Gu\u00edas de Django, por Mozilla .","title":"Para leer m\u00e1s"}]}